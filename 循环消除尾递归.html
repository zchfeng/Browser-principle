<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>循环消除尾递归解释</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      color: #333;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      max-width: 900px;
      width: 100%;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 30px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      margin-top: 20px;
    }

    h1 {
      color: #2575fc;
      text-align: center;
      margin-bottom: 20px;
      font-size: 2.2rem;
    }

    h2 {
      color: #6a11cb;
      margin: 20px 0 15px;
      padding-bottom: 8px;
      border-bottom: 2px solid #6a11cb;
    }

    p {
      line-height: 1.6;
      margin-bottom: 15px;
      font-size: 1.05rem;
    }

    .code-container {
      background: #2d2d2d;
      color: #f8f8f2;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      overflow-x: auto;
      font-family: 'Consolas', 'Monaco', monospace;
    }

    .code-comment {
      color: #75715e;
    }

    .code-keyword {
      color: #f92672;
    }

    .code-function {
      color: #e6db74;
    }

    .code-param {
      color: #fd971f;
    }

    .code-number {
      color: #ae81ff;
    }

    .code-string {
      color: #a6e22e;
    }

    .comparison {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }

    .recursion,
    .loop {
      flex: 1;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .explanation {
      background: #e3f2fd;
      padding: 15px;
      border-left: 5px solid #2575fc;
      border-radius: 4px;
      margin: 15px 0;
    }

    .important {
      color: #d32f2f;
      font-weight: bold;
    }

    .visualization {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }

    button {
      padding: 10px 20px;
      background: #2575fc;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.3s ease;
    }

    button:hover {
      background: #6a11cb;
      transform: translateY(-2px);
    }

    input {
      padding: 10px;
      border: 2px solid #2575fc;
      border-radius: 8px;
      font-size: 1rem;
      width: 80px;
      text-align: center;
    }

    .result {
      margin-top: 20px;
      font-weight: bold;
      text-align: center;
    }

    @media (max-width: 768px) {
      .comparison {
        flex-direction: column;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>循环消除尾递归</h1>

    <h2>什么是循环消除尾递归？</h2>
    <p>循环消除尾递归是一种编程技术，通过将尾递归函数转换为等效的循环结构，来避免递归调用带来的性能问题和栈溢出风险。</p>

    <div class="explanation">
      <p>由于大多数JavaScript引擎没有实现尾调用优化(TCO)，即使使用尾递归，仍然可能导致栈溢出。循环消除尾递归是一种可靠的解决方案。</p>
    </div>

    <h2>尾递归 vs 循环实现</h2>
    <div class="comparison">
      <div class="recursion">
        <h3>尾递归实现</h3>
        <div class="code-container">
          <pre><span class="code-keyword">function</span> <span class="code-function">factorial</span>(<span class="code-param">n</span>, <span class="code-param">acc</span> = <span class="code-number">1</span>) {
  <span class="code-keyword">if</span> (n === <span class="code-number">1</span>) <span class="code-keyword">return</span> acc;
  <span class="code-comment">// 尾递归调用</span>
  <span class="code-keyword">return</span> <span class="code-function">factorial</span>(n - <span class="code-number">1</span>, n * acc);
}</pre>
        </div>
        <p>虽然这是尾递归形式，但大多数JS引擎仍会创建新的栈帧，可能导致栈溢出。</p>
      </div>

      <div class="loop">
        <h3>循环实现</h3>
        <div class="code-container">
          <pre><span class="code-keyword">function</span> <span class="code-function">factorialLoop</span>(<span class="code-param">n</span>) {
  <span class="code-keyword">let</span> result = <span class="code-number">1</span>;
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = n; i > <span class="code-number">1</span>; i--) {
    result *= i;
  }
  <span class="code-keyword">return</span> result;
}</pre>
        </div>
        <p>使用循环完全避免了递归调用，不会增加调用栈深度，更加安全高效。</p>
      </div>
    </div>

    <h2>为什么需要循环消除尾递归？</h2>
    <p>1. <strong>避免栈溢出</strong>：递归深度过大会导致栈溢出错误，而循环没有这个限制。</p>
    <p>2. <strong>性能更好</strong>：函数调用比循环迭代有更高的开销，循环通常执行更快。</p>
    <p>3. <strong>兼容性</strong>：不依赖JavaScript引擎的尾调用优化实现。</p>
    <p>4. <strong>调试更容易</strong>：循环的调用栈更简单，更容易调试和理解。</p>

    <h2>转换示例：斐波那契数列</h2>
    <div class="comparison">
      <div class="recursion">
        <h3>尾递归版本</h3>
        <div class="code-container">
          <pre><span class="code-keyword">function</span> <span class="code-function">fibonacci</span>(<span class="code-param">n</span>, <span class="code-param">a</span> = <span class="code-number">0</span>, <span class="code-param">b</span> = <span class="code-number">1</span>) {
  <span class="code-keyword">if</span> (n === <span class="code-number">0</span>) <span class="code-keyword">return</span> a;
  <span class="code-keyword">if</span> (n === <span class="code-number">1</span>) <span class="code-keyword">return</span> b;
  <span class="code-keyword">return</span> <span class="code-function">fibonacci</span>(n - <span class="code-number">1</span>, b, a + b);
}</pre>
        </div>
      </div>

      <div class="loop">
        <h3>循环版本</h3>
        <div class="code-container">
          <pre><span class="code-keyword">function</span> <span class="code-function">fibonacciLoop</span>(<span class="code-param">n</span>) {
  <span class="code-keyword">let</span> a = <span class="code-number">0</span>, b = <span class="code-number">1</span>;
  <span class="code-keyword">if</span> (n === <span class="code-number">0</span>) <span class="code-keyword">return</span> a;
  
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">2</span>; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  
  <span class="code-keyword">return</span> b;
}</pre>
        </div>
      </div>
    </div>

    <h2>实践演示</h2>
    <div class="visualization">
      <p>输入一个数字，计算它的阶乘：</p>

      <div class="controls">
        <input type="number" id="numberInput" min="1" max="100" value="10">
        <button onclick="calculateFactorial()">计算阶乘</button>
      </div>

      <div class="result" id="resultOutput"></div>
    </div>

    <h2>何时使用循环消除尾递归？</h2>
    <p>1. 当处理大数据集或深度递归时</p>
    <p>2. 当性能是关键因素时</p>
    <p>3. 当代码需要在不同JS环境中运行时</p>
    <p>4. 当递归函数可以自然地转换为循环时</p>

    <div class="explanation">
      <p class="important">注意：不是所有递归都能轻松转换为循环。某些算法（如树遍历）的递归形式更直观，但在可能的情况下，考虑使用循环消除尾递归可以提高代码的健壮性和性能。</p>
    </div>
  </div>

  <script>
    function calculateFactorial() {
      const n = parseInt(document.getElementById('numberInput').value);
      if (isNaN(n) || n < 1) {
        document.getElementById('resultOutput').textContent = "请输入有效的正整数";
        return;
      }

      // 使用循环实现
      let result = 1;
      for (let i = n; i > 1; i--) {
        result *= i;
      }

      document.getElementById('resultOutput').textContent = `${n}! = ${result}`;
    }
  </script>
</body>

</html>